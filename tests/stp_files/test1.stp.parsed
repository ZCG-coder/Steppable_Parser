'source_file' : "mat1 =
| 1 3 4 5 8 9 |
| 4 5 6 8 9 0 |
| 4 2 2 1 2 1 |
| 3 2 4 1 2 4 |
| 3 2 4 1 2 4 |;

mat2 = \
| 1*2^3 3 4 5 8 9 |
| 4 5 6 8 9 0 |
| 4 2 2 1 2 1 |
| 3 2 4 1 2 4 |
| 3 2 4 1 2 4 |

obj1 {
    mat = | 1 2 3 4 5 |
}

fn1 Mat m, Mat n -> Mat {
    m * (n + 3)
}

var1 = (3 mod (2+4) + 5) + 2
if type(var1) == "number" {
    "Great! \{var1\} is a number. \r \n"
} else {
    "Totally wrong!"
}

obj.mat = mat1;

a = sin(15)

foreach x in mat1 {
    x = x ^ 2
}

mat1 * mat2
mat1 .* mat2

# Operators
# Binary
# ^ & * / - + == != > < >= <= .* ./ .^
# Unary
# ! + -

sum(mat1)

mat1 = mat1 * mat2

import module
stat = module.learn()

stat

#comment

12% + 11% * (1+2)

x = symbol("x")
expr = x^2 == 4
vals = solve(expr)

"Unicode \xFE\xFF \033[1f;"
"
'assignment' : "mat1 =
| 1 3 4 5 8 9 |"
mat1
matrix
'expression_statement' : "| 4 5 6 8 9 0 |"
'expression_statement' : "| 4 2 2 1 2 1 |"
'expression_statement' : "| 3 2 4 1 2 4 |"
'expression_statement' : "| 3 2 4 1 2 4 |;"
'assignment' : "mat2 = \
| 1*2^3 3 4 5 8 9 |"
mat2
matrix
'expression_statement' : "| 4 5 6 8 9 0 |"
'expression_statement' : "| 4 2 2 1 2 1 |"
'expression_statement' : "| 3 2 4 1 2 4 |"
'expression_statement' : "| 3 2 4 1 2 4 |"
'object_definition' : "obj1 {
    mat = | 1 2 3 4 5 |
}"
'function_definition' : "fn1 Mat m, Mat n -> Mat {
    m * (n + 3)
}"
'assignment' : "var1 = (3 mod (2+4) + 5) + 2"
var1
binary_expression
'if_else_stmt' : "if type(var1) == "number" {
    "Great! \{var1\} is a number. \r \n"
} else {
    "Totally wrong!"
}"
'assignment' : "obj.mat = mat1;"
'assignment' : "a = sin(15)"
a
function_call
'foreach_in_stmt' : "foreach x in mat1 {
    x = x ^ 2
}"
'expression_statement' : "mat1 * mat2"
'expression_statement' : "mat1 .* mat2"
'expression_statement' : "sum(mat1)"
'assignment' : "mat1 = mat1 * mat2"
mat1
binary_expression
'import_statement' : "import module"
'assignment' : "stat = module.learn()"
stat
function_call
'expression_statement' : "stat"
'expression_statement' : "12% + 11% * (1+2)"
'assignment' : "x = symbol("x")"
x
function_call
'assignment' : "expr = x^2 == 4"
expr
binary_expression
'assignment' : "vals = solve(expr)"
vals
function_call
'expression_statement' : ""Unicode \xFE\xFF \033[1f;""
